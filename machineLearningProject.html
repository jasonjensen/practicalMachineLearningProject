<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>Practical Machine Learning course project</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Practical Machine Learning course project</h1>

<h2>Introduction</h2>

<p>In this project, we use the Weight Lifting Exercises Dataset provided by <a href="http://groupware.les.inf.puc-rio.br/har#weight_lifting_exercises#weight_lifting_exercises">Groupware@LES</a> to create a machine which classifies the quality of a person&#39;s Unilateral Dumbell Biceps Curl exercises based on a number of sensor readings.</p>

<p>Groupware classified one &ldquo;correct&rdquo; curl, labeled &ldquo;A&rdquo;, and five &ldquo;incorrect&rdquo; curls labelled &ldquo;B&rdquo; through &ldquo;C&rdquo;:</p>

<ul>
<li>A: correct unilateral dumbell biceps curl</li>
<li>B: throwing the elbows to the front</li>
<li>C: lifting the dumbbell only halfway</li>
<li>D: lowering the dumbbell only halfway</li>
<li>E: throwing the hips to the front</li>
</ul>

<h2>Approach</h2>

<p>I am a bit unsure exactly which methods will be most useful, so I will partition the data into three parts. A training set, an initial test set (named midTest), and then a small error estimation set. I will build an array of rpart and Random Forest models on the training set. The best model will then be chosen on the midTest sample, and the final out of sample error of the best model will be estimated on the errorEstSample sample.</p>

<h2>Load data</h2>

<p>I chose 80%, 15%, and 5%, respectively for my training, midTest, and error estimation samples. As these were partitioned sequentially from smallest to largest, the actual shares of the training data are  76%, 14.25%, and 5%, respectively.</p>

<pre><code class="r">library(Hmisc)  #data exploration
library(caret)  #machine learning
library(rpart)  #rpart caret method
library(randomForest)  #random forest caret method
library(e1071)  #confusion matrix
library(ggplot2)  #plotting


training &lt;- read.csv(&quot;pml-training.csv&quot;)
testing &lt;- read.csv(&quot;pml-testing.csv&quot;)

# partition data into training, probe, and estimation set for Out-of-Sample
# errors
set.seed(254684)
inErrorEstSample &lt;- createDataPartition(y = training$classe, p = 0.05, list = FALSE)
errorEstSample &lt;- training[inErrorEstSample, ]
training &lt;- training[-inErrorEstSample, ]
inMidTest &lt;- createDataPartition(y = training$classe, p = 0.15, list = FALSE)
midTest &lt;- training[inMidTest, ]
training &lt;- training[-inMidTest, ]
</code></pre>

<h2>Cleaning the data</h2>

<p>The data is not initially suited for inclusion in a training model. First, there are a number of &ldquo;bookkeeping&rdquo; variables in the front which are not relevant to our goal of deriving classifications from sensor measurement data, so these must be cleared. </p>

<p>After a bit of exploration it also became clear that many of the variables contained mostly missing values and that the non-missing values in these variables were coded as factor variables. I created a helper function which (with a few warnings) strips these variables from the data frame. I then applied this helper function to all the data sets.</p>

<pre><code class="r"># helper function. Removes variables with no variance
myTrim &lt;- function(df) {
    outcome &lt;- df$classe
    df &lt;- df[, 8:159]  #drop variables at front and outcome variable
    nonConstant &lt;- apply(df, 2, function(x) !is.na(var(x)))
    df &lt;- df[, nonConstant]  #drop constant variables
    df$classe &lt;- outcome  #add outcome variable
    return(df)
}

# apply trim to samples
training &lt;- myTrim(training)
midTest &lt;- myTrim(midTest)
errorEstSample &lt;- myTrim(errorEstSample)
</code></pre>

<h2>Model Prediction</h2>

<p>As noted, I am fitting an array of models; mainly bootstrapped rpart and random forests of different lengths. The fitting is quite computationally intensive. A helpful <a href="http://stackoverflow.com/questions/22200923/different-results-with-formula-and-non-formula-for-caret-training">internet source</a> suggested using a non-formula interface to speed up computations when there are no factor variables in the data set. As I cleared out the factor variables above, I call the train function with a matrix and a vector, rather than a formula and a data parameter.</p>

<pre><code class="r"># vary rpart tuneLength: 5-25
bootControl &lt;- trainControl(method = &quot;boot632&quot;, number = 25)
modelBoot5 &lt;- train(training[, 1:52], training$classe, method = &quot;rpart&quot;, trControl = bootControl, 
    tuneLength = 5)
modelBoot10 &lt;- train(training[, 1:52], training$classe, method = &quot;rpart&quot;, trControl = bootControl, 
    tuneLength = 10)
modelBoot15 &lt;- train(training[, 1:52], training$classe, method = &quot;rpart&quot;, trControl = bootControl, 
    tuneLength = 15)
modelBoot20 &lt;- train(training[, 1:52], training$classe, method = &quot;rpart&quot;, trControl = bootControl, 
    tuneLength = 20)
modelBoot25 &lt;- train(training[, 1:52], training$classe, method = &quot;rpart&quot;, trControl = bootControl, 
    tuneLength = 25)
</code></pre>

<pre><code class="r"># vary rf tuneLength: 1-3
modelRF1 &lt;- train(training[, 1:52], training$classe, method = &quot;rf&quot;, tuneLength = 1, 
    ntree = 25)
modelRF2 &lt;- train(training[, 1:52], training$classe, method = &quot;rf&quot;, tuneLength = 2, 
    ntree = 25)
modelRF3 &lt;- train(training[, 1:52], training$classe, method = &quot;rf&quot;, tuneLength = 3, 
    ntree = 25)
</code></pre>

<h2>Comparing the models</h2>

<p>The code below basically calculates the accuracy of the various models above on the training and the midTest data sets and outputs a table of results.</p>

<pre><code class="r"># compare models on the midTest data

# helper functions
myAccTrain &lt;- function(x) {
    t &lt;- confusionMatrix(data = predict(x, newdata = training), training$classe)
    return(t$overall[1])
}

myAccTest &lt;- function(x) {
    t &lt;- confusionMatrix(data = predict(x, newdata = midTest), midTest$classe)
    return(t$overall[1])
}

# list of models to compare
modelList &lt;- list(modelBoot5 = modelBoot5, modelBoot10 = modelBoot10, modelBoot15 = modelBoot15, 
    modelBoot20 = modelBoot20, modelBoot25 = modelBoot25, modelRF1 = modelRF1, 
    modelRF2 = modelRF2, modelRF3 = modelRF3)

# create accuracy estimates
trainAccuracy &lt;- lapply(modelList, myAccTrain)
testAccuracy &lt;- lapply(modelList, myAccTest)

# combine and view results
overview &lt;- cbind(names(modelList), trainAccuracy, testAccuracy)
overview
</code></pre>

<pre><code>##                           trainAccuracy testAccuracy
## modelBoot5  &quot;modelBoot5&quot;  0.5437        0.5359      
## modelBoot10 &quot;modelBoot10&quot; 0.6854        0.666       
## modelBoot15 &quot;modelBoot15&quot; 0.7642        0.7413      
## modelBoot20 &quot;modelBoot20&quot; 0.7984        0.7814      
## modelBoot25 &quot;modelBoot25&quot; 0.8239        0.8131      
## modelRF1    &quot;modelRF1&quot;    1             0.995       
## modelRF2    &quot;modelRF2&quot;    1             0.9932      
## modelRF3    &quot;modelRF3&quot;    1             0.9925
</code></pre>

<p>The bootstrapped rpart models improve their fit as we increase tuneLength (as would be expected given increased subpartitioning), but even with 25 levels they do not compare to the random forest model with achieves a near-perfect fit in all cases. ModelRF1 is chosen as the fit is excellent and the computation time is less than for models RF2 and RF3.</p>

<h2>Model Error</h2>

<p>As we have yet to use the third data set which we set aside for estimating the out of sample error of the best model, we can now employ it to accurately estimate the out of sample error rate of the modelRF1 predictior. Our best estimate for the Out of Sample error rate is 0.6%. It appears we can create a very accurate model of  Unilateral Dumbell Biceps Curl quality, given enough sensor data.</p>

<pre><code class="r">confMat &lt;- confusionMatrix(data = predict(modelRF1, newdata = errorEstSample), 
    errorEstSample$classe)
estimatedOOSErrorRate &lt;- 1 - confMat$overall[[1]]  #1 - accuracy
estimatedOOSErrorRate
</code></pre>

<pre><code>## [1] 0.006104
</code></pre>

<h2>A little more detail.</h2>

<p>Random forests are hard to interpret, but the impratance variable does help this measure a bit.</p>

<pre><code class="r">impData &lt;- as.data.frame(importance(modelRF1$finalModel))

# identify measurement area
impData$rowname &lt;- rownames(impData)
impData$type &lt;- &quot;arm&quot;
belt &lt;- lapply(impData$rowname, function(x) grepl(pattern = &quot;belt&quot;, x))
forearm &lt;- lapply(impData$rowname, function(x) grepl(pattern = &quot;forearm&quot;, x))
dumbbell &lt;- lapply(impData$rowname, function(x) grepl(pattern = &quot;dumbbell&quot;, 
    x))
impData$type &lt;- ifelse(belt, &quot;belt&quot;, impData$type)
impData$type &lt;- ifelse(forearm, &quot;forearm&quot;, impData$type)
impData$type &lt;- ifelse(dumbbell, &quot;dumbbell&quot;, impData$type)
impData &lt;- impData[order(impData$MeanDecreaseGini), ]
impData$index &lt;- 1:52

importancePlot &lt;- ggplot(impData, aes(factor(type), MeanDecreaseGini, colour = factor(type), 
    size = MeanDecreaseGini)) + geom_jitter() + labs(title = &quot;Importance of Variables by Sensor Location&quot;, 
    xlab = &quot;&quot;)
importancePlot
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk Exploring the random tree"/> </p>

<p>From the plot above it can be inferred that if we are limited in the number of sensors we can apply in the future, the best sensor location for distinguishing a correct unilateral dumbbell curl from various incorrect ones is the belt, followed by the dumbbell. Two of the foream variables have large importance, but the arm variable provides little additional information.</p>

<h2>Predicting on the supplied test set</h2>

<p>All that is left is to apply the model to the supplied testing data. The resulting assignments can be seen below the r code:</p>

<pre><code class="r">testPredictions &lt;- predict(modelRF1, newdata = myTrim(testing))
testing$predicted_classe &lt;- testPredictions
head(testing[c(&quot;user_name&quot;, &quot;problem_id&quot;, &quot;predicted_classe&quot;)], n = 20)
</code></pre>

<pre><code>##    user_name problem_id predicted_classe
## 1      pedro          1                B
## 2     jeremy          2                A
## 3     jeremy          3                B
## 4     adelmo          4                A
## 5     eurico          5                A
## 6     jeremy          6                E
## 7     jeremy          7                D
## 8     jeremy          8                B
## 9   carlitos          9                A
## 10   charles         10                A
## 11  carlitos         11                B
## 12    jeremy         12                C
## 13    eurico         13                B
## 14    jeremy         14                A
## 15    jeremy         15                E
## 16    eurico         16                E
## 17     pedro         17                A
## 18  carlitos         18                B
## 19     pedro         19                B
## 20    eurico         20                B
</code></pre>

</body>

</html>

